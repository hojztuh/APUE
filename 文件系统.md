## 文件系统概述

**类ls的实现，myls，支持-l -a -i -n等**

`$ls --all -a 非选项的传参`

`/etc/passwd`

`/etc/group`

## 目录和文件

###获取文件属性

```c
// stat, fstat, lstat
int stat(const char *pathname, struct stat *statbuf);
struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
};

// st_blksize * st_blocks 是一个文件所占真实的磁盘大小
```

空洞文件

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220301160126011.png" alt="image-20220301160126011" style="zoom:50%;" />

上图是用自己手写的mycpy和系统的cp函数拷贝一个5G大小的文件的对比情况

### 文件访问权限

`st_mode`是一个十六位的整型数，类型是`mode_t`(7种**文件类型**用3位表示，9位**普通权限**，3位**特殊权限**，一共需要15位，所以16位的整型数足够了)

+ 文件类型有7种

dcb-lsp: directory, character device, block device, regular, link(符号链接/软链接), socket, pipe 

可以用`$man 7 inode`去查找有关`st_mode`的内容，里面有确定文件类型的宏定义

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220301165324620.png" alt="image-20220301165324620" style="zoom:50%;" />

### umask

`权限 = 0666 & ~umask`

**umask机制的存在是为了防止产生权限过松的文件**

`mode_t umask(mode_t mask);`

### 文件权限更改/管理

```c
// chmod, fchmod
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
```

### 粘住位

t位: 原本是给二进制的可执行文件设计的，现在基本是给**目录**使用的

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220301180647868.png" alt="image-20220301180647868" style="zoom:50%;" />

### 文件系统

文件系统: 可以归结为**文件或数据的存储格式问题**

#### FAT

**本质是一个静态存储的单链表**

缺点：

+ 由于结点数量有限，单个文件大小存在上限
+ 由于使用单链表，每次要从头结点检索

优点：

+ 轻量

#### UFS

与FAT文件系统是同一时期的产物

磁盘->分区->块组

+ 优点：不怕大文件
+ 缺点：存在大量小文件时，查找速度偏慢

文件名存在**目录文件**里，目录文件里有若干个**目录项**，目录项记录**inode与文件名的对应关系**

### 硬链接和符号链接

#### 硬链接

`$ln <src_file> <dst_file>`

+ 硬链接与目录项是同义词，且建立硬链接有限制: 不能给分区建立，不能给目录建立

+ 硬链接本质上是一个文件（两个指针指向同一个数据块）

#### 符号链接

`$ln -s <src_file> <dst_file>`

+ 符号链接本质上是两个不同的文件，可以理解为快捷方式
+ 符号链接的优点在于可以夸分区，可以给目录建立

####常用系统调用

```c
int link(const char *oldpath, const char *newpath);	// ln由link封装
int unlink(const char *pathname);
int remove(const char *pathname); // rm由remove封装
int rename(const char *oldpath, const char *newpath); // mv由rename封装
```

### utime

ls中显示的是***modified time***

`int utime(const char *filename, const struct utimbuf *times);`

utime函数可以更改文件的a time和m time，即最后读的时间和最后写的时间。

### 目录的创建和销毁

`int mkdir(const char *pathname, mode_t mode);`

`int rmdir(const char *pathname);`

### 更改当前工作路径

`int chdir(const char *path);`

`int fchdir(int fd);`

`int chroot(const char *path);`

`char *getcwd(char *buf, size_t size); // 获取当前的工作路径`

### 分析目录/读取目录内容

**这部分的重点是实现自己的du程序**

方案一：使用glob函数解析模式/通配符

```c
// errfunc是函数指针，负责搞定出错的路径和原因
int glob(const char *pattern, int flags,
                int (*errfunc) (const char *epath, int eerrno),
                glob_t *pglob);
       void globfree(glob_t *pglob);
typedef struct {
               size_t   gl_pathc;    /* Count of paths matched so far  */
               char   **gl_pathv;    /* List of matched pathnames.  */
               size_t   gl_offs;     /* Slots to reserve in gl_pathv.  */
           } glob_t;
// gl_pathc和gl_pathv可以类比命令行参数的argc和argv，前者是一个整数，后者是一个字符指针的首地址
```

方案二：使用一系列函数

+ opendir();
+ closedir();
+ readdir();
+ rewinddir();
+ seekdir();
+ telldir();

## 系统数据文件和信息

### /etc/passwd

**用户信息**

并不是所有的Linux/Unix系统都有这个文件，比如：FreeBSD系统，用一个小型的数据库BDB来存放所有的用户信息

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220310154820879.png" alt="image-20220310154820879" style="zoom:50%;" />

因此，需要统一的接口来获取**用户信息**

```c
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
```

### /etc/group

```c
struct group *getgrgid(gid_t gid);
struct group *getgrnam(const char *name);
```

###/etc/shadow

**安全就是使攻击成本大于收益**

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220310163723191.png" alt="image-20220310163723191" style="zoom:50%;" />

```c
struct spwd *getspnam(const char *name);
char *crypt(const char *phrase, const char *setting);
char *getpass(const char *prompt);
```

### 时间戳

计算机最喜欢大整数(时间戳time_t)，人类最喜欢字符串(char *)，程序员最喜欢结构体(struct tm)

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220311144056148.png" alt="image-20220311144056148" style="zoom: 33%;" />

```c
// time_t, char *, struct tm
time();
gmtime();
localtime();
mktime();
strftime();
```



## 进程环境

### 进程的终止

**背过5+3**

1. 正常终止

+ 从main函数返回

`return 0;`实际上是将0返回给当前进程的**父进程**

+ 调用exit()
+ 调用\_exit()或\_Exit()
+ 最后一个线程从其**启动例程**返回
+ 最后一个线程调用了pthrea_exit()

2. 异常终止

+ 调用abort()
+ 接收到一个信号并终止
+ 最后一个线程对其取消请求作出响应

3. **钩子函数**

```c
int atexit(void (*function)(void));
```

### 命令行参数的解析

```c
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
int getopt_long(int argc, char * const argv[],
                  const char *optstring,
                  const struct option *longopts, int *longindex);
```

### 环境变量

环境变量就是KEY = VALUE

可以用`export`命令查看环境变量

PATH是一个环境变量

 ```c
 #include <stdio.h>
 #include <stdlib.h>
 
 extern char **environ; // 全局变量，是一个字符指针数组
 
 int main() {
 
     for (int i = 0; environ[i] != NULL; i++) {
         puts(environ[i]);
     }
 
     return 0;
 }
 ```



```c
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite); // 如果要修改name对应的值，则需要释放掉旧的值，然后在堆中申请新的空间
int putenv(char *string);

```



### C程序的存储空间布局

<img src="https://gitee.com/hojztuh/My_Img/raw/master/Img/image-20220319151134190.png" alt="image-20220319151134190" style="zoom:50%;" />

可以使用`pmap`命令来查看进程的内存布局

### 库

+ 动态库
+ 静态库
+ 共享库/手工装载库

```c
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
```



### 函数跳转

goto不能实现跨函数跳转

```c
int setjmp(jmp_buf env); // 执行一次返回两次
void longjmp(jmp_buf env, int val);
```



### 资源的获取及控制

```c
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);

struct rlimit {
               rlim_t rlim_cur;  /* Soft limit */
               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
// 普通用户可以升高/降低soft limit，可以降低但不可以升高hard limit
// root用户可以升高/降低soft limit，可以升高/降低hard limit
```

